<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />

<!-- qunit -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<link rel="stylesheet" href="http://code.jquery.com/qunit/qunit-git.css" type="text/css" />
<script src="//code.jquery.com/qunit/qunit-1.14.0.js"></script>

<!-- testrunner -->
<script src="../../../js/reporter.js"></script>
<script src="../../../moxie_loader.js"></script>

<script type="text/javascript" src="../../XMLHttpRequest/image-b64.js"></script>

<script type="text/javascript">

QUnit.config.reorder = false;
QUnit.config.testTimeout = 10000;
QUnit.config.autostart = false;


var jpegs = [
	{
		desc: '',
		path: '../../Image/exif/00da154a-0107-11e4-8336-3377b25ece3d.jpg',
		expect: {
			TIFF: {
				Make: 'TCT',
				Orientation: 1
			},
			EXIF: {
				PixelXDimension: 2560,
				PixelYDimension: 1440,
				MeteringMode: 'CenterWeightedAverage',
				LightSource: 'Other',
				Flash: 'Flash fired',
				FNumber: 2.8
			}
		}
	},
	{
		desc: '',
		path: '../../Image/exif/20111119122131.jpg',
		expect: {
			TIFF: {
				Make: 'Motorola'
			},
			EXIF: {
				PixelXDimension: 1920,
				PixelYDimension: 2560,
				DateTimeOriginal: '2011:11:19 12:21:30'
			}
		}
	},
	{
		desc: '',
		path: '../../Image/exif/3a5140ea-44fd-11e2-8df2-55ebef1da60e.jpg',
		expect: {
			EXIF: {
				PixelXDimension: 3264,
				PixelYDimension: 2448,
				MeteringMode: 'Pattern',
				Flash: 'Flash did not fire, auto mode',
				FNumber: 2.4
			}
		}
	},
	{
		desc: "Doesn't resize, #1146",
		path: '../../Image/exif/img_0647.jpg',
		expect: {
			TIFF: {
				Model: 'Canon EOS 1100D',
				Orientation: 1
			},
			EXIF: {
				PixelXDimension: 4272,
				PixelYDimension: 2848,
				MeteringMode: 'Pattern',
				Flash: 'Flash did not fire, compulsory flash mode',
				FNumber: 5.6
			}
		}
	}
];


module("HTML5: JPEGHeaders", {
	data: (function() {
		var data = o.atob(imgB64);
		return [data, str2ab(data)];
	}())
});

test("Instantiation", function(assert) {
	var jh, result;

	try {
		jh = new o.JPEGHeaders("not a jpeg");
		result = false;
	} catch(ex) {
		result = ex.code === o.Exceptions.ImageError.WRONG_FORMAT;
	}

	assert.ok(result, "Throw ImageError.WRONG_FORMAT when instantiated with invalid data.");

	o.each(this.data, function(data) {
		jh = new o.JPEGHeaders(data);

		assert.equal(jh.headers.length, 3, "APPn-s found and extracted: " + o.typeOf(data));

		var props = ['hex', 'name', 'start', 'length', 'segment'];
		var countProps = 0;
		o.each(props, function(prop) {
			if (prop in jh.headers[0]) {
				countProps++;
			}
		});
		assert.equal(countProps, props.length, "APPn attributes extracted: " + o.typeOf(data));

		jh.purge();
		assert.deepEqual(jh.headers, [], "Instance destroyed: " + o.typeOf(data));
	});
});


test("get()", function(assert) {
	var jh, data = o.atob(imgB64), headers, APP1, APP1_copy;

	jh = new o.JPEGHeaders(data);
	headers = jh.headers;

	assert.equal(headers[0].name, "APP1", "First header is APP1.");
	
	assert.deepEqual({
		hex: headers[0].hex,
		length: headers[0].length,
		name: headers[0].name
	}, {
		hex: 65505,
		length: 26,
		name: "APP1"
	}, "APP1 attributes populated properly");

	APP1 = jh.get("APP1");
	assert.ok(APP1.length, "APP1 extracted.");

	APP1_copy = jh.get("app1");
	assert.deepEqual(APP1, APP1_copy, "APPn identifier case shouldn't matter.");
});



module("HTML5: ExifParser");

test("Basic things", function(assert) {
	var ep, jh, data = o.atob(imgB64);

	var result;
	try {
		ep = new o.ExifParser("not a jpeg");
		result = false;
	} catch (ex) {
		result = true;
	}
	assert.ok(result, "JPEG that doesn't contain Exif should trigger exception.");


	jh = new o.JPEGHeaders(data);
	ep = new o.ExifParser(jh.get("APP1")[0]);

	assert.equal(ep.ASCII(4), 'E', "ASCII()");
	assert.equal(ep.STRING(4, 4), 'Exif', "STRING()");
	

	ep.clear();
	assert.deepEqual(ep.SEGMENT(), null, "Instance destroyed properly.");
	assert.deepEqual(ep.length(), 0, "Length is 0 after destruction.");

	jh.purge();
});


module("HTML5: Problematic JPEGs");

o.each(jpegs, function(jpeg) {
	var desc = jpeg.desc ? jpeg.path + ': ' + jpeg.desc : jpeg.path;
	test(desc, function(assert) {
		var jh = new o.JPEGHeaders(jpeg.source);
		var ep = new o.ExifParser(jh.get("app1")[0]);

		o.each(jpeg.expect, function(info, method) {
			var data = ep[method]();

			if (!data) {
				assert.ok(false, "Exif data cannot be extracted");
			}

			o.each(info, function(value, key) {
				assert.equal(data[key], value, method + ' - ' + key + ': ' + value);
			});
		});
	});
});
	


function str2ab(str) {
	var buf = new ArrayBuffer(str.length); // 2 bytes for each char
	var bufView = new Uint8Array(buf);
	for (var i = 0, strLen = str.length; i < strLen; i++) {
		bufView[i] = str.charCodeAt(i);
	}
	return buf;
}

function ab2str(buf) {
	return String.fromCharCode.apply(null, new Uint8Array(buf));
}

// load files ans start QUnit
(function() {
	var queue = [];

	$.each(jpegs, function(i, jpeg) {
		queue.push(function(cb) {
			var xhr = new XMLHttpRequest();
			xhr.responseType = 'blob';
			xhr.open('get', jpeg.path);
			
			xhr.onload = function() {
				var fr = new FileReader();
				
				fr.onload = function() {
					jpeg.source = this.result;
					cb();
				};

				fr.onerror = function() {
					cb("File cannot be loaded.");
				};

				fr.readAsArrayBuffer(this.response);
			};

			xhr.onerror = function() {
				cb("File cannot be loaded.");
			};

			xhr.send();
		});
	});

	o.inParallel(queue, function(err) {
		if (err) {
			throw err;
		}
		QUnit.start();
	});
}());

</script>
</head>
<body>
	<div id="qunit"></div>
    <div id="qunit-fixture" style="position: relative; top: 0 !important; left: 0 !important; width: 100%; height: 9px;"></div>
</body>
</html>


